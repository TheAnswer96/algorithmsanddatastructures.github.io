<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithms and Data Structures: A Premise</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- External Google Fonts for futuristic and minimalist fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Lato:wght@300;400&family=Roboto:wght@300;400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>

     <header class="text-center my-5">
        <h1 class="display-4">Algorithms and Data Structures: Graphs</h1>
    </header>

    <main class="container">
        <!-- Introduction Section -->
        <section id="introduction" class="mb-5">
            <h2 class="h2 mb-3">Introduction</h2>
            <p class="lead">
                A graph G=(V, E) consists of a set of vertices V and a set of edges E.
                A <strong>vertex</strong> is a node in a graph. An <strong>edge</strong> represents a link between two vertices.
            </p>
            <figure class="text-center">
                <img src="images/graph.svg" class="img-fluid w-25 rounded shadow-sm">
                <figcaption class="text-muted mt-3">A graph.</figcaption>
            </figure>

            <p class="lead">
                The <strong>degree</strong> of a vertex is the number of edges that are incident to the vertex.
                An edge (u,v) is <strong>incident</strong> to vertices u and v.
            </p>

            <p class="lead">Typical graph operations are:</p>

            <div class="container mt-5">
                <!-- Time Complexity Table -->
                <div class="table-responsive">
                    <table class="table table-bordered table-hover complexity-table">
                        <thead class="table-dark">
                            <tr>
                                <th>Operation</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td> <code>add_edge(x,y)</code> </td>
                                <td>Add the edge(x,y) to  E.</td>
                            </tr>
                            <tr>
                                <td><code>add_vertex(x)</code></td>
                                <td>
                                    Add vertex x to V.
                                </td>
                            </tr>
                            <tr>
                                <td><code>remove_edge(x,y)</code></td>
                                <td>
                                    Remove the edge(x,y) to E.
                                </td>
                            </tr>
                            <tr>
                                <td><code>has_edge(x,y)</code></td>
                                <td>
                                    Check if the edge(x,y) belongs to E.
                                </td>
                            </tr>
                            <tr>
                                <td><code>out_edge(x)</code></td>
                                <td>
                                    Return a List of all the x outbound edges.
                                </td>
                            </tr>
                            <tr>
                                <td><code>in_edge(x)</code></td>
                                <td>
                                    Return a List of all the x inbound edges.
                                </td>
                            </tr>
                            <tr>
                                <td><code>remove_edge(x,y)</code></td>
                                <td>
                                    Remove the edge(x,y) to E.
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <br>

            <h3 class="h3 mb-3">Graph properties</h3>
            <p class="lead">
                Graph properties affect the data structure used to represent the graph and the algorithms available to interact with them.
            </p>

            <p class="lead">
                <strong>Undirected vs directed: </strong> A graph G=(V,E) is undirected if an edge(x,y) in set E means that  (x,y) is also in set  E.
                If this is not the case, then the graph is a directed graph
            </p>

            <figure class="text-center">
                <img src="images/dgraph.svg" class="img-fluid w-25 rounded shadow-sm">
                <figcaption class="text-muted mt-3">An undirected graph and a directed graph.</figcaption>
            </figure>

            <p class="lead">
                Directed graphs are common when representing dependencies, which have a parent-child relationship.
            </p>

            <p class="lead">
                <strong>Weighted vs unweighted: </strong> In a weighted graph each edge is assigned a value (a weight). For example, the edge in a road network might be assigned a cost for drive time.
            </p>

            <figure class="text-center">
                <img src="images/weighted.svg" class="img-fluid w-25 rounded shadow-sm">
                <figcaption class="text-muted mt-3">A weighted graph.</figcaption>
            </figure>

            <p class="lead">In an unweighted graph there is no value associated with an edge.</p>

            <p class="lead">
                <strong>Simple vs non-simple:</strong> A simple graph is a graph without self-loops or multiple edges.
            </p>

            <figure class="text-center">
                <img src="images/non-simple.svg" class="img-fluid w-25 rounded shadow-sm">
                <figcaption class="text-muted mt-3">A non-simple graph with a self-loop and multiple edges.</figcaption>
            </figure>

            <p class="lead"> A non-simple graph can contain these types of edges.</p>

            <p class="lead">
                <strong>Sparse vs dense: </strong>A graph is sparse if only a small number of the possible vertex pairs have edges defined between them.
                A dense graph is a graph where lots of the possible vertex pairs have edges defined between them.
                Dense graphs typically have a quadratic number of edges.
            </p>

            <p class="lead">
                <strong>Cyclic vs acyclic: </strong> Cyclic graphs contain cycles, Acyclic graphs do not.
                Trees are acyclic graphs.
            </p>

            <p class="lead">
                <strong>Labelled vs unlabelled:</strong> In a labelled graph, each vertex is assigned a unique name. In an unlabelled graph, vertices do not have an associated name.
            </p>

            <h2 class="h2 mb-3">Representing a Graph</h2>

            <p class="lead">
                There are two common ways to represent a graph G=(V,E):
            </p>
            <ul class="lead">
                <li>Adjacency matrix</li>
                <li>Adjacency list</li>
            </ul>

            <h3 class="h3 mb-3">Adjacency matrix</h3>
            <p class="lead">
                An <strong>adjacency matrix</strong> is a nxn M, where n is the number of vertices.
            </p>
            <p class="lead">
                M[x,y]=1 if (x,y) is an edge of G, and 0 if it is not.
            </p>

            <figure class="text-center">
                <img src="images/adjacency-matrix.svg" class="img-fluid w-25 rounded shadow-sm">
                <figcaption class="text-muted mt-3">A graph and its adjacency matrix.</figcaption>
            </figure>

            <p class="lead">
                Common operations like <code>add_edge()</code>, <code>remove_edge()</code>, and <code>has_edge()</code> are O(1) operations.
            </p>
            <div class="container mt-5">
                <!-- Add Edge Function Example -->
                <div class="example-container mb-4">
                    <div class="example">
                        <p class="text-left"><b>void</b> add_edge(<b>int</b> x, <b>int</b> y) {</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;a[x][y] = 1;</p>
                        <p class="text-left">}</p>
                    </div>
                </div>

                <!-- Remove Edge Function Example -->
                <div class="example-container mb-4">
                    <div class="example">
                        <p class="text-left"><b>void</b> remove_edge(<b>int</b> x, <b>int</b> y) {</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;a[x][y] = 0;</p>
                        <p class="text-left">}</p>
                    </div>
                </div>

                <!-- Has Edge Function Example -->
                <div class="example-container mb-4">
                    <div class="example">
                        <p class="text-left"><b>bool</b> has_edge(<b>int</b> x, <b>int</b> y) {</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b> a[x][y] == 1;</p>
                        <p class="text-left">}</p>
                    </div>
                </div>
            </div>

            <p class="lead">
                Methods returning edges for a given node, e.g. <code>out_edges()</code>/<code>in_edges()</code>, are O(n) operations.
                An entire row/column must be checked to find the edges.
                Another problem with adjacency matrices is that they quickly grow large. For this reason they are often impractical.
            </p>

            <h3 class="h3 mb-3">Adjacency list</h3>

            <p class="lead">
                An <strong>adjacency list</strong> is a data structure that uses an array of lists to store the edges of vertices.
                Adjacency lists are more efficient at representing sparse graphs than adjacency matrices.
                An adjacency list can be represented with a <code>graph</code> struct and an <code>edgenode</code> struct.
                Each vertex is assigned a unique identifier from 1 to <code>nvertices</code>.
                The edges on a vertex <code>x</code> are included as a linked list of <code>edgenodes</code> starting at the <code>edgenode</code> at <code>nvertices[x]</code>.
            </p>

            <div class="container mt-5">
                <!-- MAXV Constant Example -->
                <div class="example-container mb-4">
                    <div class="example">
                        <p class="text-left"><b>const int</b> MAXV = 1000;</p>
                    </div>
                </div>

                <!-- Edgenode Struct Example -->
                <div class="example-container mb-4">
                    <div class="example">
                        <p class="text-left"><b>typedef struct</b> {</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b> y;</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b> weight;</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>struct edgenode</b> *next;</p>
                        <p class="text-left">}</p>
                        <p class="text-left"><b>edgenode</b>;</p>
                    </div>
                </div>

                <!-- Graph Struct Example -->
                <div class="example-container mb-4">
                    <div class="example">
                        <p class="text-left"><b>typedef struct</b> {</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>edgenode</b> *edges[MAXV+1];</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b> degree[MAXV+1];</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b> nvertices;</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>bool</b> directed;</p>
                        <p class="text-left">}</p>
                        <p class="text-left"><b>graph</b>;</p>
                    </div>
                </div>
            </div>

            <p class="lead">
                A directed edge (x,y) is represented as a y <code>edgenode</code> in x's adjacency list (at <code>g->edges[x]</code>).
                undirected edge appears twice, once in x's list as y, and once in y's list as x.
            </p>

            <figure class="text-center">
                <img src="images/adjacency-list.svg" class="img-fluid w-25 rounded shadow-sm">
                <figcaption class="text-muted mt-3">A graph and its adjacency list.</figcaption>
            </figure>

            <p class="lead">
                The following code initializes an adjacency list with m vertices:
            </p>
            <div class="example-container mb-4">
                <div class="example">
                    <p class="text-left"><b>void</b> initialize_graph(<b>graph</b> *g, <b>bool</b> directed, <b>int</b> m) {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b> i;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b> x;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b> y;</p>
                    <br>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;g->nvertices = n;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;g->nedges = m;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;g->directed = directed;</p>
                    <br>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b> (i = 1; i <= m; i++) {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g->degree[i] = 0;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                    <br>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b> (i = 1; i <= m; i++) {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g->edges[i] = NULL;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                    <p class="text-left">}</p>
                </div>
            </div>

            <p class="lead">
                Edges can be added from a 2D array:
            </p>

            <div class="example-container mb-4">
                <div class="example">
                    <p class="text-left"><b>int</b> example_edges[4][2] = { {1, 2}, {1, 4}, {1, 3}, {3, 4} };</p>
                    <br>
                    <p class="text-left"><b>void</b> add_edges(<b>graph</b> *g, <b>bool</b> directed, <b>int</b> m, <b>int</b> edges[][2]) {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b> x;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b> y;</p>
                    <br>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b> (<b>int</b> i = 0; i &lt; m; i++) {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = edges[i][0];</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = edges[i][1];</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insert_edge(g, x, y, directed);</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                    <p class="text-left">}</p>
                    <br>
                    <p class="text-left"><b>void</b> insert_edge(<b>graph</b> *g, <b>int</b> x, <b>int</b> y, <b>bool</b> directed) {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>edgenode</b> *p;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;p = <b>malloc</b>(<b>sizeof</b>(<b>edgenode</b>));</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;p->weight = 0;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;p->y = y;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;p->next = g->edges[x];</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;g->edges[x] = p;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;g->degree[x]++;</p>
                    <br>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> (directed == <b>false</b>) {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insert_edge(g, y, x, <b>true</b>);</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;} <b>else</b> {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g->nedges++;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                    <p class="text-left">}</p>
                </div>
            </div>

            <h2 class="h2 mb-3">Graph Traversal</h2>

            <p class="lead">
                Traversing a graph to visit every edge and vertex is a common problem.
                It’s usually necessary to keep track of whether a vertex has been visited or not to avoid visiting vertices multiple times.
                This can be achieved by using a flag.
                In this section, a vertex can exist in one of three states during traversal:
            </p>
            <ul class="lead">
                <li><strong>Undiscovered</strong>. The vertex has not been visited.</li>
                <li><strong>Discovered</strong>. The vertex has been visited but all its incident edges have not yet been visited.</li>
                <li><strong>Processed</strong>. The vertex and all its incident edges have been visited.</li>
            </ul>

            <p class="lead">
                To completely explore a vertex v, each edge leaving v must be explored. Edges that go to a discovered or processed vertex are ignored.
                An undirected edge will be considered twice, once from each vertex.
                Directed edges are only considered once.
                We will look at breadth-first search (BFS) and depth-first-search (DFS) algorithms for traversing a graph.
            </p>

            <h2 class="h2 mb-3">Breadth-First Search</h2>

            <p class="lead">
                BFS (Breadth-First Search) is a common tree traversal algorithm.
                When BFS is run on an undirected graph, a direction is assigned to each edge from the discoverer u to the discovered  v.
                Thus, u is denoted as the parent of v.
                Apart from the root node, each node has one parent.
                This defines a tree of the vertices in a graph:
            </p>

            <figure class="text-center">
                <img src="images/bfs_.gif" class="img-fluid w-50 rounded shadow-sm">
                <figcaption class="text-muted mt-3">BFS logic.</figcaption>
            </figure>


            <p class="lead">
                The following is the algorithm for BFS in pseudocode:
            </p>

            <div class="example-container mb-4">
                <div class="example">
                    <p class="text-left"><b>BFS(G,s)</b></p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b> each vertex u ∈ V [G] − {s} <b>do</b></p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state[u] = “undiscovered”</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p[u] = nil, i.e. no parent is in the BFS tree</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;state[s] = “discovered”</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;p[s] = nil</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;Q = {s}</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>while</b> Q ≠ ∅ <b>do</b></p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u = dequeue[Q]</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process vertex u as desired</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b> each v ∈ Adj[u] <b>do</b></p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process edge (u,v) as desired</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> state[v] = “undiscovered” <b>then</b></p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state[v] = “discovered”</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p[v] = u</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enqueue[Q,v]</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state[u] = “processed”</p>
                </div>
            </div>

            <p class="lead">
                The following BFS implementation uses two arrays (<code>processed</code> and <code>discovered</code>) to store information about the state of a vertex (initially set to <code>false</code>).
                As well as a parent array used to store the parent of a vertex:
            </p>

            <div class="example-container mb-4">
                <div class="example">
                    <p class="text-left"><b>bool</b> processed[MAXV+1];</p>
                    <p class="text-left"><b>bool</b> discovered[MAXV+1];</p>
                    <p class="text-left"><b>int</b> parent[MAXV+1];</p>
                    <p class="text-left"></p>
                    <p class="text-left"><b>void</b> initialize_search(<b>graph</b> *g) {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b> (<b>int</b> i = 1; i <= g-&gt;nvertices; i++) {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processed[i] = discovered[i] = <b>FALSE</b>;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent[i] = -1;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                    <p class="text-left">}</p>
                </div>
            </div>

            <p class="lead">
                In BFS, a vertex is placed on a queue when it is discovered.
                This means the oldest vertices (the ones closest to the root) are expanded first.
            </p>

            <div class="example-container mb-4">
                <div class="example">
                    <p class="text-left"><b>void</b> bfs(<b>graph</b> *g, <b>int</b> start) {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>queue</b> q;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b> v;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b> y;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>edgenode</b> *p;</p>
                    <p class="text-left"></p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;init_queue(&q);</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;enqueue(&q, start);</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;discovered[start] = <b>TRUE</b>;</p>
                    <p class="text-left"></p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>while</b> (empty_queue(&q) == <b>FALSE</b>) {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v = dequeue(&q);</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process_vertex_early(v);</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processed[v] = <b>TRUE</b>;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = g-&gt;edges[v];</p>
                    <p class="text-left"></p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>while</b> (p != <b>NULL</b>) {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = p-&gt;y;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> ((processed[y] == <b>FALSE</b>) || g-&gt;directed) {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process_edge(v, y);</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                    <p class="text-left"></p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> (discovered[y] == <b>FALSE</b>) {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enqueue(&q, y);</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;discovered[y] = <b>TRUE</b>;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent[y] = v;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = p-&gt;next;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process_vertex_late(v);</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                    <p class="text-left">}</p>
                </div>
            </div>

            <p class="lead">
                The behavior of BFS is defined by the functions <code>process_vertex_early()</code>, <code>process_edge()</code>, and <code>process_vertex_late()</code>.
                The vertex that discovered vertex <code>i</code> is at <code>parent[i]</code>.
                Because vertices are discovered in order of increasing distance from the root node, the tree path from each node  x ∈ V uses the minimum number of edges on a root-to-x path.
                The path from a vertex can be reconstructed by following the chain of parents:
            </p>

            <div class="example-container mb-4">
                <div class="example">
                    <p class="text-left"><b>void</b> find_path(<b>int</b> start, <b>int</b> end, <b>int</b> parents[]) {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> ((start == end) || (end == -1)) {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(<span class="text-warning">"\n%d"</span>, start);</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;} <b>else</b> {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;find_path(start, parents[end], parents);</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(<span class="text-warning">" %d"</span>, end);</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                    <p class="text-left">}</p>
                </div>
            </div>

            <ul class="lead">
                <li>The BFS shortest path tree from x to y is only useful if x is the root of the tree.</li>
                <li>BFS only gives shortest path if path is unweighted.</li>
            </ul>

            <p class="lead">
                BFS runs in O(n+m) time on a graph of n  vertices and m edges.
            </p>

            <h2 class="h2 mb-3">Depth-First Search</h2>

            <p class="lead">
                DFS (Depth-first search) is an alternative method for visiting a graph.
                The difference between DFS and BFS is the order that they visit nodes in. DFS visits all children in a path, before backing up to previous nodes.
            </p>

            <figure class="text-center">
                <img src="images/dfs.gif" class="img-fluid w-50 rounded shadow-sm">
                <figcaption class="text-muted mt-3">DFS logic.</figcaption>
            </figure>

            <p class="lead">
                DFS uses a stack to store discovered nodes that need to be processed (instead of a queue like BFS).
                DFS can also be defined recursively (implicitly using the language call stack), which eliminates the use of an explicit stack:
            </p>

            <div class="example-container mb-4">
                <div class="example">
                    <p class="text-left"><b>void</b> DFS(<b>graph</b> G, <b>int</b> u) {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;state[u] = <span class="text-warning">“discovered”</span>;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;process_vertex(u); <b>// Process vertex u if desired</b></p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;entry[u] = time;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;time = time + 1;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b> each v ∈ Adj[u] <b>do</b> {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process_edge(u, v); <b>// Process edge (u,v) if desired</b></p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> state[v] = <span class="text-warning">“undiscovered”</span> <b>then</b> {</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p[v] = u;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>DFS(G, v);</b></p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;state[u] = <span class="text-warning">“processed”</span>;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;exit[u] = time;</p>
                    <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;time = time + 1;</p>
                    <p class="text-left">}</p>
                </div>
            </div>

            <p class="lead">Time intervals in DFS are useful for:</p>

            <ul class="lead">
                <li>Determining an ancestor. An ancestor will have a lower entry time than its descendants.</li>
                <li>Determining number of descendants. The difference in entry and exit time determines how many descendants a vertex has.</li>
            </ul>

            <p class="lead">
                A DFS partitions edges of an undirected graph into tree edges and back edges.
                <strong>Tree edges</strong> discover new vertices, and are encoded in the parent relation.
                <strong>Back edges</strong> are edges whose other endpoint is an ancestor of the vertex being expanded.
            </p>

            <figure class="text-center">
                <img src="images/back.svg" class="img-fluid w-50 rounded shadow-sm">
                <figcaption class="text-muted mt-3">DFS tree with tree edges and back edge.</figcaption>
            </figure>

            <p class="lead">
                DFS runs in O(n+m) time on a graph of n  vertices and m edges.
            </p>

            <section id="exercises" class="mb-5">
                <h2 class="h2 mb-3">It's Evaluation Time!</h2>

                <p class="lead">
                    The theoretical program of this section spans over the concept of graphs, BFS visit, and DFS visit.
                    This time is more crucial to understand the logic behind the introduced concepts rather than make memory tests.
                    It is pretty common that students are able to memoize algorithm's pseudocodes but demostrating a lack of comprehension on their logic.
                    Hence, a good way to evaluate them is to propose problems where standard well-known algorithm must be extended in order to return the correct solution.
                    Let's see some examples:
                </p>

                <h3 class="h3 mb-3">Example 1</h3>
                <!-- asymptotic proof -->
                <p class="lead">
                    Given a graph G=(V, E) write an algorithm for computing how many connected components there are in G.
                </p>

                <p class="lead">
                    A connected component of an undirected graph is a set of vertices where there is a path between each pair of vertices.
                    Components are separate pieces of a graph if there is no connection between the pieces.
                </p>


                <figure class="text-center">
                    <img src="images/connected-components.svg" class="img-fluid w-50 rounded shadow-sm">
                    <figcaption class="text-muted mt-3">Connected components.</figcaption>
                </figure>

                <p class="lead">
                    All components of a graph can be found by looping through its vertices, starting a new breadth-first or depth-first search whenever the loop reaches a vertex that has not already been included in a previously found component.
                    Let's see the pseudocode that relies on BFS:
                </p>

                <div class="example-container mb-4">
                    <div class="example">
                        <p class="text-left"><b>void</b> connected_components(<b>graph</b> *g) {</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b> c; <b>// component number</b></p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b> i; <b>// counter</b></p>

                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;initialize_search(g);</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;c = 0;</p>

                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b> (i = 1; i <= g->nvertices; i++) {</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> (discovered[i] == <span class="text-warning">FALSE</span>) {</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = c + 1;</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(<span class="text-warning">"Component %d:"</span>, c);</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bfs(g, i);</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(<span class="text-warning">"\n"</span>);</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                        <p class="text-left">}</p>
                    </div>
                </div>

                <p class="lead">
                    The time complexity of this algorihtm is O(n+m).
                </p>

                <h3 class="h3 mb-3">Example 2</h3>
                <!-- order functions -->
                <p class="lead">
                    Given a graph G=(V, E) write an algorithm for determing whether or not it exists at least one cycle in G.
                </p>

                <p class="lead">
                    If there is a back edge from  (x,y) then a cycle exists between x and y.
                    If there are no back edges, then there are no cycles.
                </p>

                <p class="lead">
                    We can check for cycles with <code>dfs()</code> by a small modification:
                </p>

                <div class="example-container mb-4">
                    <div class="example">
                        <p class="text-left"><b>void</b> DFS(<b>graph</b> G, <b>int</b> u) {</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;state[u] = <span class="text-warning">“discovered”</span>;</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;entry[u] = time;</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;time = time + 1;</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b> each v ∈ Adj[u] <b>do</b> {</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> state[v] = <span class="text-warning">“processed”</span> <b>then</b> {</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return “cycle”;</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> state[v] = <span class="text-warning">“undiscovered”</span> <b>then</b> {</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p[v] = u;</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>DFS(G, v);</b></p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;state[u] = <span class="text-warning">“processed”</span>;</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;exit[u] = time;</p>
                        <p class="text-left">&nbsp;&nbsp;&nbsp;&nbsp;time = time + 1;</p>
                        <p class="text-left">}</p>
                    </div>
                </div>

                <p class="lead">
                    The time complexity of this algorihtm is O(n+m).
                </p>

                <div class="container text-center">
                    <button class="btn btn-primary lesson-btn" onclick="window.location.href='index.html'">Return to Home</button>
                </div>
            </section>
        </section>



    </main>

    <footer class="text-center mt-5 py-4 bg-light">
        <p class="text-muted">&copy; 2024 Didattica degli Algoritmi.   </p>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js"></script>
   <script src="js/bfs-visualization.js"></script>
</body>
</html>
